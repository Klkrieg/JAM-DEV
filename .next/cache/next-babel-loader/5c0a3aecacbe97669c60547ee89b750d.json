{"ast":null,"code":"import mongoose from \"mongoose\";\nconst UserSchema = new mongoose.Schema({\n  name: {\n    type: String,\n    required: true\n  }\n});\nexport default (async (req, res) => {\n  const connection = await mongoose.createConnection(process.env.MONGODB_URI, {\n    useNewUrlParser: true,\n    bufferCommands: false,\n    bufferMaxEntries: 0,\n    useUnifiedTopology: true\n  });\n\n  try {\n    const User = connection.model(\"User\", UserSchema);\n    const {\n      query: {\n        name\n      },\n      method\n    } = req;\n\n    switch (method) {\n      case \"POST\":\n        User.create({\n          name\n        }, (error, user) => {\n          if (error) {\n            connection.close();\n            res.status(500).json({\n              error\n            });\n          } else {\n            res.status(200).json(user);\n            connection.close();\n          }\n        });\n        break;\n\n      default:\n        res.setHeader(\"Allow\", [\"POST\"]);\n        res.status(405).end(`Method ${method} Not Allowed`);\n    }\n  } catch (e) {\n    connection.close();\n    res.status(500).json({\n      error: e.message || \"something went wrong\"\n    });\n  }\n}); // //import bcrypt from \"bcrypt\";\n// import Users from \"../../../models/users.js\";\n// import dbConnect from \"../../../utils/dbConnect\";\n// dbConnect();\n// export default async (req, res) => {\n// \tconst { method } = req;\n// \tswitch (method) {\n// \t\tcase \"GET\":\n// \t\t\ttry {\n// \t\t\t\tconst users = await Users.find({});\n// \t\t\t\tres.status(200).json({ success: \"true\", data: users });\n// \t\t\t} catch {\n// \t\t\t\tres.status(400);\n// \t\t\t}\n// \t\t\tbreak;\n// \t\tcase \"POST\":\n// \t\t\ttry {\n// \t\t\t\tconst user = await Users.create(req.body);\n// \t\t\t\tres.status(201).json({ success: true, data: user });\n// \t\t\t} catch {\n// \t\t\t\tres.status(400).json({ succes: false });\n// \t\t\t}\n// \t}\n// };","map":{"version":3,"sources":["/Users/karsonkrieg/Desktop/JAM-DEV/pages/api/users/index.js"],"names":["mongoose","UserSchema","Schema","name","type","String","required","req","res","connection","createConnection","process","env","MONGODB_URI","useNewUrlParser","bufferCommands","bufferMaxEntries","useUnifiedTopology","User","model","query","method","create","error","user","close","status","json","setHeader","end","e","message"],"mappings":"AAAA,OAAOA,QAAP,MAAqB,UAArB;AACA,MAAMC,UAAU,GAAG,IAAID,QAAQ,CAACE,MAAb,CAAoB;AACtCC,EAAAA,IAAI,EAAE;AACLC,IAAAA,IAAI,EAAEC,MADD;AAELC,IAAAA,QAAQ,EAAE;AAFL;AADgC,CAApB,CAAnB;AAMA,gBAAe,OAAOC,GAAP,EAAYC,GAAZ,KAAoB;AAClC,QAAMC,UAAU,GAAG,MAAMT,QAAQ,CAACU,gBAAT,CAA0BC,OAAO,CAACC,GAAR,CAAYC,WAAtC,EAAmD;AAC3EC,IAAAA,eAAe,EAAE,IAD0D;AAE3EC,IAAAA,cAAc,EAAE,KAF2D;AAG3EC,IAAAA,gBAAgB,EAAE,CAHyD;AAI3EC,IAAAA,kBAAkB,EAAE;AAJuD,GAAnD,CAAzB;;AAMA,MAAI;AACH,UAAMC,IAAI,GAAGT,UAAU,CAACU,KAAX,CAAiB,MAAjB,EAAyBlB,UAAzB,CAAb;AACA,UAAM;AACLmB,MAAAA,KAAK,EAAE;AAAEjB,QAAAA;AAAF,OADF;AAELkB,MAAAA;AAFK,QAGFd,GAHJ;;AAIA,YAAQc,MAAR;AACC,WAAK,MAAL;AACCH,QAAAA,IAAI,CAACI,MAAL,CAAY;AAAEnB,UAAAA;AAAF,SAAZ,EAAsB,CAACoB,KAAD,EAAQC,IAAR,KAAiB;AACtC,cAAID,KAAJ,EAAW;AACVd,YAAAA,UAAU,CAACgB,KAAX;AACAjB,YAAAA,GAAG,CAACkB,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEJ,cAAAA;AAAF,aAArB;AACA,WAHD,MAGO;AACNf,YAAAA,GAAG,CAACkB,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqBH,IAArB;AACAf,YAAAA,UAAU,CAACgB,KAAX;AACA;AACD,SARD;AASA;;AACD;AACCjB,QAAAA,GAAG,CAACoB,SAAJ,CAAc,OAAd,EAAuB,CAAC,MAAD,CAAvB;AACApB,QAAAA,GAAG,CAACkB,MAAJ,CAAW,GAAX,EAAgBG,GAAhB,CAAqB,UAASR,MAAO,cAArC;AAdF;AAgBA,GAtBD,CAsBE,OAAOS,CAAP,EAAU;AACXrB,IAAAA,UAAU,CAACgB,KAAX;AACAjB,IAAAA,GAAG,CAACkB,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEJ,MAAAA,KAAK,EAAEO,CAAC,CAACC,OAAF,IAAa;AAAtB,KAArB;AACA;AACD,CAjCD,E,CAmCA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import mongoose from \"mongoose\";\nconst UserSchema = new mongoose.Schema({\n\tname: {\n\t\ttype: String,\n\t\trequired: true,\n\t},\n});\nexport default async (req, res) => {\n\tconst connection = await mongoose.createConnection(process.env.MONGODB_URI, {\n\t\tuseNewUrlParser: true,\n\t\tbufferCommands: false,\n\t\tbufferMaxEntries: 0,\n\t\tuseUnifiedTopology: true,\n\t});\n\ttry {\n\t\tconst User = connection.model(\"User\", UserSchema);\n\t\tconst {\n\t\t\tquery: { name },\n\t\t\tmethod,\n\t\t} = req;\n\t\tswitch (method) {\n\t\t\tcase \"POST\":\n\t\t\t\tUser.create({ name }, (error, user) => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tconnection.close();\n\t\t\t\t\t\tres.status(500).json({ error });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres.status(200).json(user);\n\t\t\t\t\t\tconnection.close();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tres.setHeader(\"Allow\", [\"POST\"]);\n\t\t\t\tres.status(405).end(`Method ${method} Not Allowed`);\n\t\t}\n\t} catch (e) {\n\t\tconnection.close();\n\t\tres.status(500).json({ error: e.message || \"something went wrong\" });\n\t}\n};\n\n// //import bcrypt from \"bcrypt\";\n// import Users from \"../../../models/users.js\";\n// import dbConnect from \"../../../utils/dbConnect\";\n\n// dbConnect();\n\n// export default async (req, res) => {\n// \tconst { method } = req;\n// \tswitch (method) {\n// \t\tcase \"GET\":\n// \t\t\ttry {\n// \t\t\t\tconst users = await Users.find({});\n// \t\t\t\tres.status(200).json({ success: \"true\", data: users });\n// \t\t\t} catch {\n// \t\t\t\tres.status(400);\n// \t\t\t}\n// \t\t\tbreak;\n// \t\tcase \"POST\":\n// \t\t\ttry {\n// \t\t\t\tconst user = await Users.create(req.body);\n// \t\t\t\tres.status(201).json({ success: true, data: user });\n// \t\t\t} catch {\n// \t\t\t\tres.status(400).json({ succes: false });\n// \t\t\t}\n// \t}\n// };\n"]},"metadata":{},"sourceType":"module"}