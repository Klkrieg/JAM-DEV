{"ast":null,"code":"import bcrypt from \"bcrypt\";\nimport Users from \"../../../models/users.js\";\nimport dbConnect from \"../../../utils/dbConnect\";\nexport default (async (req, res, connection) => {\n  dbConnect();\n  const {\n    method\n  } = req;\n\n  switch (method) {\n    case \"GET\":\n      try {\n        const users = await Users.find({});\n        res.status(200).json({\n          success: true,\n          data: users\n        });\n      } catch {\n        res.status(400);\n      }\n\n      break;\n\n    case \"POST\":\n      // Users.create(req.body, (err, user) => {\n      // \tif (err) {\n      // \t\treturn res.status(400).json(err);\n      // \t} else {\n      // \t\treturn res.status(200).json({ success: true, user });\n      // \t}\n      // });\n      Users.findOne({\n        email: req.body.email\n      }, \"email\", async (err, user) => {\n        try {\n          if (user) {\n            console.log(\"A user with that email already exists.\");\n            res.status(409).send();\n          } else if (!user) {\n            const salt = await bcrypt.genSalt();\n            const hashedPass = await bcrypt.hash(req.body.password, salt);\n            req.body.password = hashedPass;\n            Users.create(req.body, (err, user) => {\n              if (err) {\n                return res.status(400).json(err);\n              } else {\n                return res.status(200).json({\n                  success: true,\n                  user\n                });\n              }\n            });\n          }\n        } catch {\n          res.send(err);\n        }\n      });\n      break;\n\n    default:\n      res.status(400).json({\n        succes: false\n      });\n  }\n}); // router.post(\"/api/users\", (req, res) => {\n// \tUsers.findOne({ email: req.body.email }, \"email\", async (err, user) => {\n// \t\ttry {\n// \t\t\tif (user) {\n// \t\t\t\tconsole.log(\"A user with that email already exists.\");\n// \t\t\t\tres.status(409).send();\n// \t\t\t} else if (!user) {\n// \t\t\t\tconst salt = await bcrypt.genSalt();\n// \t\t\t\tconst hashedPass = await bcrypt.hash(req.body.password, salt);\n// \t\t\t\treq.body.password = hashedPass;\n// \t\t\t\tUsers.create(body)\n// \t\t\t\t\t.then((dbUsers) => {\n// \t\t\t\t\t\tres.json(dbUsers);\n// \t\t\t\t\t})\n// \t\t\t\t\t.catch((err) => {\n// \t\t\t\t\t\tconsole.log(err);\n// \t\t\t\t\t\tres.status(400).json(err);\n// \t\t\t\t\t});\n// \t\t\t}\n// \t\t} catch {\n// \t\t\tres.send(err);\n// \t\t}\n// \t});\n// });","map":{"version":3,"sources":["/Users/karsonkrieg/Desktop/JAM-DEV/pages/api/users/index.js"],"names":["bcrypt","Users","dbConnect","req","res","connection","method","users","find","status","json","success","data","findOne","email","body","err","user","console","log","send","salt","genSalt","hashedPass","hash","password","create","succes"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,QAAnB;AACA,OAAOC,KAAP,MAAkB,0BAAlB;AACA,OAAOC,SAAP,MAAsB,0BAAtB;AAEA,gBAAe,OAAOC,GAAP,EAAYC,GAAZ,EAAiBC,UAAjB,KAAgC;AAC9CH,EAAAA,SAAS;AACT,QAAM;AAAEI,IAAAA;AAAF,MAAaH,GAAnB;;AACA,UAAQG,MAAR;AACC,SAAK,KAAL;AACC,UAAI;AACH,cAAMC,KAAK,GAAG,MAAMN,KAAK,CAACO,IAAN,CAAW,EAAX,CAApB;AACAJ,QAAAA,GAAG,CAACK,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,UAAAA,OAAO,EAAE,IAAX;AAAiBC,UAAAA,IAAI,EAAEL;AAAvB,SAArB;AACA,OAHD,CAGE,MAAM;AACPH,QAAAA,GAAG,CAACK,MAAJ,CAAW,GAAX;AACA;;AACD;;AACD,SAAK,MAAL;AACC;AACA;AACA;AACA;AACA;AACA;AACA;AACAR,MAAAA,KAAK,CAACY,OAAN,CAAc;AAAEC,QAAAA,KAAK,EAAEX,GAAG,CAACY,IAAJ,CAASD;AAAlB,OAAd,EAAyC,OAAzC,EAAkD,OAAOE,GAAP,EAAYC,IAAZ,KAAqB;AACtE,YAAI;AACH,cAAIA,IAAJ,EAAU;AACTC,YAAAA,OAAO,CAACC,GAAR,CAAY,wCAAZ;AACAf,YAAAA,GAAG,CAACK,MAAJ,CAAW,GAAX,EAAgBW,IAAhB;AACA,WAHD,MAGO,IAAI,CAACH,IAAL,EAAW;AACjB,kBAAMI,IAAI,GAAG,MAAMrB,MAAM,CAACsB,OAAP,EAAnB;AACA,kBAAMC,UAAU,GAAG,MAAMvB,MAAM,CAACwB,IAAP,CAAYrB,GAAG,CAACY,IAAJ,CAASU,QAArB,EAA+BJ,IAA/B,CAAzB;AACAlB,YAAAA,GAAG,CAACY,IAAJ,CAASU,QAAT,GAAoBF,UAApB;AACAtB,YAAAA,KAAK,CAACyB,MAAN,CAAavB,GAAG,CAACY,IAAjB,EAAuB,CAACC,GAAD,EAAMC,IAAN,KAAe;AACrC,kBAAID,GAAJ,EAAS;AACR,uBAAOZ,GAAG,CAACK,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqBM,GAArB,CAAP;AACA,eAFD,MAEO;AACN,uBAAOZ,GAAG,CAACK,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,kBAAAA,OAAO,EAAE,IAAX;AAAiBM,kBAAAA;AAAjB,iBAArB,CAAP;AACA;AACD,aAND;AAOA;AACD,SAhBD,CAgBE,MAAM;AACPb,UAAAA,GAAG,CAACgB,IAAJ,CAASJ,GAAT;AACA;AACD,OApBD;AAqBA;;AACD;AACCZ,MAAAA,GAAG,CAACK,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEiB,QAAAA,MAAM,EAAE;AAAV,OAArB;AAxCF;AA0CA,CA7CD,E,CA+CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import bcrypt from \"bcrypt\";\nimport Users from \"../../../models/users.js\";\nimport dbConnect from \"../../../utils/dbConnect\";\n\nexport default async (req, res, connection) => {\n\tdbConnect();\n\tconst { method } = req;\n\tswitch (method) {\n\t\tcase \"GET\":\n\t\t\ttry {\n\t\t\t\tconst users = await Users.find({});\n\t\t\t\tres.status(200).json({ success: true, data: users });\n\t\t\t} catch {\n\t\t\t\tres.status(400);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"POST\":\n\t\t\t// Users.create(req.body, (err, user) => {\n\t\t\t// \tif (err) {\n\t\t\t// \t\treturn res.status(400).json(err);\n\t\t\t// \t} else {\n\t\t\t// \t\treturn res.status(200).json({ success: true, user });\n\t\t\t// \t}\n\t\t\t// });\n\t\t\tUsers.findOne({ email: req.body.email }, \"email\", async (err, user) => {\n\t\t\t\ttry {\n\t\t\t\t\tif (user) {\n\t\t\t\t\t\tconsole.log(\"A user with that email already exists.\");\n\t\t\t\t\t\tres.status(409).send();\n\t\t\t\t\t} else if (!user) {\n\t\t\t\t\t\tconst salt = await bcrypt.genSalt();\n\t\t\t\t\t\tconst hashedPass = await bcrypt.hash(req.body.password, salt);\n\t\t\t\t\t\treq.body.password = hashedPass;\n\t\t\t\t\t\tUsers.create(req.body, (err, user) => {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\treturn res.status(400).json(err);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn res.status(200).json({ success: true, user });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} catch {\n\t\t\t\t\tres.send(err);\n\t\t\t\t}\n\t\t\t});\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tres.status(400).json({ succes: false });\n\t}\n};\n\n// router.post(\"/api/users\", (req, res) => {\n// \tUsers.findOne({ email: req.body.email }, \"email\", async (err, user) => {\n// \t\ttry {\n// \t\t\tif (user) {\n// \t\t\t\tconsole.log(\"A user with that email already exists.\");\n// \t\t\t\tres.status(409).send();\n// \t\t\t} else if (!user) {\n// \t\t\t\tconst salt = await bcrypt.genSalt();\n// \t\t\t\tconst hashedPass = await bcrypt.hash(req.body.password, salt);\n// \t\t\t\treq.body.password = hashedPass;\n// \t\t\t\tUsers.create(body)\n// \t\t\t\t\t.then((dbUsers) => {\n// \t\t\t\t\t\tres.json(dbUsers);\n// \t\t\t\t\t})\n// \t\t\t\t\t.catch((err) => {\n// \t\t\t\t\t\tconsole.log(err);\n// \t\t\t\t\t\tres.status(400).json(err);\n// \t\t\t\t\t});\n// \t\t\t}\n// \t\t} catch {\n// \t\t\tres.send(err);\n// \t\t}\n// \t});\n// });\n"]},"metadata":{},"sourceType":"module"}