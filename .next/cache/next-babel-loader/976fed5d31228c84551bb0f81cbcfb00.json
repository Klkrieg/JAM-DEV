{"ast":null,"code":"import bcrypt from \"bcrypt\";\nimport Users from \"../../../models/users.js\";\nimport dbConnect from \"../../../utils/dbConnect\";\ndbConnect();\nexport default (async (req, res) => {\n  const {\n    method\n  } = req;\n\n  switch (method) {\n    case \"GET\":\n      try {\n        const users = await Users.find({});\n        res.status(200).json({\n          success: true,\n          data: users\n        });\n      } catch {\n        res.status(400);\n      }\n\n      break;\n\n    case \"POST\":\n      try {\n        // const user = await Users.create(req.body);\n        Users.findOne({\n          email: req.body.email\n        }, \"email\", async (err, user) => {\n          try {\n            if (user) {\n              res.status(409).json({\n                message: \"A user with that email already exists.\"\n              });\n            } else if (!user) {\n              const salt = await bcrypt.genSalt();\n              const hashedPass = await bcrypt.hash(req.body.password, salt);\n              body.password = hashedPass;\n              Users.create(body).then(dbUsers => {\n                res.json(dbUsers);\n              }).catch(err => {\n                console.log(err);\n                res.status(400).json(err, {\n                  message: \"dbCreate failed\"\n                });\n              });\n            }\n          } catch {\n            res.send(err);\n          }\n        });\n        res.status(201).json({\n          success: true,\n          data: user\n        });\n      } catch {\n        res.status(400).json({\n          succes: false\n        });\n      }\n\n      break;\n\n    default:\n      res.status(400).json({\n        succes: false\n      });\n  }\n}); // router.post(\"/api/users\", ({ body }, res) => {\n// \tUsers.findOne({ email: req.body.email }, \"email\", async (err, user) => {\n// \t\ttry {\n// \t\t\tif (user) {\n// \t\t\t\tconsole.log(\"A user with that email already exists.\");\n// \t\t\t\tres.status(409).send();\n// \t\t\t} else if (!user) {\n// \t\t\t\tconst salt = await bcrypt.genSalt();\n// \t\t\t\tconst hashedPass = await bcrypt.hash(body.password, salt);\n// \t\t\t\tbody.password = hashedPass;\n// \t\t\t\tUsers.create(body)\n// \t\t\t\t\t.then((dbUsers) => {\n// \t\t\t\t\t\tres.json(dbUsers);\n// \t\t\t\t\t})\n// \t\t\t\t\t.catch((err) => {\n// \t\t\t\t\t\tconsole.log(err);\n// \t\t\t\t\t\tres.status(400).json(err);\n// \t\t\t\t\t});\n// \t\t\t}\n// \t\t} catch {\n// \t\t\tres.send(err);\n// \t\t}\n// \t});\n// });","map":{"version":3,"sources":["/Users/karsonkrieg/Desktop/JAM-DEV/pages/api/users/index.js"],"names":["bcrypt","Users","dbConnect","req","res","method","users","find","status","json","success","data","findOne","email","body","err","user","message","salt","genSalt","hashedPass","hash","password","create","then","dbUsers","catch","console","log","send","succes"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,QAAnB;AACA,OAAOC,KAAP,MAAkB,0BAAlB;AACA,OAAOC,SAAP,MAAsB,0BAAtB;AAEAA,SAAS;AAET,gBAAe,OAAOC,GAAP,EAAYC,GAAZ,KAAoB;AAClC,QAAM;AAAEC,IAAAA;AAAF,MAAaF,GAAnB;;AACA,UAAQE,MAAR;AACC,SAAK,KAAL;AACC,UAAI;AACH,cAAMC,KAAK,GAAG,MAAML,KAAK,CAACM,IAAN,CAAW,EAAX,CAApB;AACAH,QAAAA,GAAG,CAACI,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,UAAAA,OAAO,EAAE,IAAX;AAAiBC,UAAAA,IAAI,EAAEL;AAAvB,SAArB;AACA,OAHD,CAGE,MAAM;AACPF,QAAAA,GAAG,CAACI,MAAJ,CAAW,GAAX;AACA;;AACD;;AACD,SAAK,MAAL;AACC,UAAI;AACH;AACAP,QAAAA,KAAK,CAACW,OAAN,CAAc;AAAEC,UAAAA,KAAK,EAAEV,GAAG,CAACW,IAAJ,CAASD;AAAlB,SAAd,EAAyC,OAAzC,EAAkD,OAAOE,GAAP,EAAYC,IAAZ,KAAqB;AACtE,cAAI;AACH,gBAAIA,IAAJ,EAAU;AACTZ,cAAAA,GAAG,CAACI,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AACpBQ,gBAAAA,OAAO,EAAE;AADW,eAArB;AAGA,aAJD,MAIO,IAAI,CAACD,IAAL,EAAW;AACjB,oBAAME,IAAI,GAAG,MAAMlB,MAAM,CAACmB,OAAP,EAAnB;AACA,oBAAMC,UAAU,GAAG,MAAMpB,MAAM,CAACqB,IAAP,CAAYlB,GAAG,CAACW,IAAJ,CAASQ,QAArB,EAA+BJ,IAA/B,CAAzB;AACAJ,cAAAA,IAAI,CAACQ,QAAL,GAAgBF,UAAhB;AACAnB,cAAAA,KAAK,CAACsB,MAAN,CAAaT,IAAb,EACEU,IADF,CACQC,OAAD,IAAa;AAClBrB,gBAAAA,GAAG,CAACK,IAAJ,CAASgB,OAAT;AACA,eAHF,EAIEC,KAJF,CAISX,GAAD,IAAS;AACfY,gBAAAA,OAAO,CAACC,GAAR,CAAYb,GAAZ;AACAX,gBAAAA,GAAG,CAACI,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqBM,GAArB,EAA0B;AAAEE,kBAAAA,OAAO,EAAE;AAAX,iBAA1B;AACA,eAPF;AAQA;AACD,WAlBD,CAkBE,MAAM;AACPb,YAAAA,GAAG,CAACyB,IAAJ,CAASd,GAAT;AACA;AACD,SAtBD;AAuBAX,QAAAA,GAAG,CAACI,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,UAAAA,OAAO,EAAE,IAAX;AAAiBC,UAAAA,IAAI,EAAEK;AAAvB,SAArB;AACA,OA1BD,CA0BE,MAAM;AACPZ,QAAAA,GAAG,CAACI,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEqB,UAAAA,MAAM,EAAE;AAAV,SAArB;AACA;;AACD;;AACD;AACC1B,MAAAA,GAAG,CAACI,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEqB,QAAAA,MAAM,EAAE;AAAV,OAArB;AAzCF;AA2CA,CA7CD,E,CA+CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import bcrypt from \"bcrypt\";\nimport Users from \"../../../models/users.js\";\nimport dbConnect from \"../../../utils/dbConnect\";\n\ndbConnect();\n\nexport default async (req, res) => {\n\tconst { method } = req;\n\tswitch (method) {\n\t\tcase \"GET\":\n\t\t\ttry {\n\t\t\t\tconst users = await Users.find({});\n\t\t\t\tres.status(200).json({ success: true, data: users });\n\t\t\t} catch {\n\t\t\t\tres.status(400);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"POST\":\n\t\t\ttry {\n\t\t\t\t// const user = await Users.create(req.body);\n\t\t\t\tUsers.findOne({ email: req.body.email }, \"email\", async (err, user) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (user) {\n\t\t\t\t\t\t\tres.status(409).json({\n\t\t\t\t\t\t\t\tmessage: \"A user with that email already exists.\",\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else if (!user) {\n\t\t\t\t\t\t\tconst salt = await bcrypt.genSalt();\n\t\t\t\t\t\t\tconst hashedPass = await bcrypt.hash(req.body.password, salt);\n\t\t\t\t\t\t\tbody.password = hashedPass;\n\t\t\t\t\t\t\tUsers.create(body)\n\t\t\t\t\t\t\t\t.then((dbUsers) => {\n\t\t\t\t\t\t\t\t\tres.json(dbUsers);\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t.catch((err) => {\n\t\t\t\t\t\t\t\t\tconsole.log(err);\n\t\t\t\t\t\t\t\t\tres.status(400).json(err, { message: \"dbCreate failed\" });\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch {\n\t\t\t\t\t\tres.send(err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tres.status(201).json({ success: true, data: user });\n\t\t\t} catch {\n\t\t\t\tres.status(400).json({ succes: false });\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tres.status(400).json({ succes: false });\n\t}\n};\n\n// router.post(\"/api/users\", ({ body }, res) => {\n// \tUsers.findOne({ email: req.body.email }, \"email\", async (err, user) => {\n// \t\ttry {\n// \t\t\tif (user) {\n// \t\t\t\tconsole.log(\"A user with that email already exists.\");\n// \t\t\t\tres.status(409).send();\n// \t\t\t} else if (!user) {\n// \t\t\t\tconst salt = await bcrypt.genSalt();\n// \t\t\t\tconst hashedPass = await bcrypt.hash(body.password, salt);\n// \t\t\t\tbody.password = hashedPass;\n// \t\t\t\tUsers.create(body)\n// \t\t\t\t\t.then((dbUsers) => {\n// \t\t\t\t\t\tres.json(dbUsers);\n// \t\t\t\t\t})\n// \t\t\t\t\t.catch((err) => {\n// \t\t\t\t\t\tconsole.log(err);\n// \t\t\t\t\t\tres.status(400).json(err);\n// \t\t\t\t\t});\n// \t\t\t}\n// \t\t} catch {\n// \t\t\tres.send(err);\n// \t\t}\n// \t});\n// });\n"]},"metadata":{},"sourceType":"module"}